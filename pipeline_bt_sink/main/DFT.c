#include "DFT.h"


/*
const DFT_Complex Rotation[N] = {
{	1.000000 	,	0.000000 	},
{	0.923880 	,	-0.382683 	},
{	0.707107 	,	-0.707107 	},
{	0.382683 	,	-0.923880 	},
{	0.000000 	,	-1.000000 	},
{	-0.382683 	,	-0.923880 	},
{	-0.707107 	,	-0.707107 	},
{	-0.923880 	,	-0.382683 	},
{	-1.000000 	,	0.000000 	},
{	-0.923880 	,	0.382683 	},
{	-0.707107 	,	0.707107 	},
{	-0.382683 	,	0.923880 	},
{	0.000000 	,	1.000000 	},
{	0.382683 	,	0.923880 	},
{	0.707107 	,	0.707107 	},
{	0.923880 	,	0.382683 	},
};
*/
const DFT_Complex Rotation[N] = {
{	1.000000 	,	0.000000 	},
{	0.995185 	,	0.098017 	},
{	0.980785 	,	0.195090 	},
{	0.956940 	,	0.290284 	},
{	0.923880 	,	0.382683 	},
{	0.881921 	,	0.471396 	},
{	0.831470 	,	0.555570 	},
{	0.773011 	,	0.634393 	},
{	0.707107 	,	0.707106 	},
{	0.634394 	,	0.773010 	},
{	0.555571 	,	0.831469 	},
{	0.471398 	,	0.881921 	},
{	0.382684 	,	0.923879 	},
{	0.290286 	,	0.956940 	},
{	0.195091 	,	0.980785 	},
{	0.098018 	,	0.995185 	},
{	0.000001 	,	1.000000 	},
{	-0.098016 	,	0.995185 	},
{	-0.195089 	,	0.980786 	},
{	-0.290283 	,	0.956941 	},
{	-0.382682 	,	0.923880 	},
{	-0.471395 	,	0.881922 	},
{	-0.555569 	,	0.831471 	},
{	-0.634392 	,	0.773012 	},
{	-0.707105 	,	0.707108 	},
{	-0.773009 	,	0.634395 	},
{	-0.831468 	,	0.555572 	},
{	-0.881920 	,	0.471399 	},
{	-0.923879 	,	0.382686 	},
{	-0.956940 	,	0.290287 	},
{	-0.980785 	,	0.195093 	},
{	-0.995184 	,	0.098020 	},
{	-1.000000 	,	0.000003 	},
{	-0.995185 	,	-0.098014 	},
{	-0.980786 	,	-0.195088 	},
{	-0.956941 	,	-0.290282 	},
{	-0.923881 	,	-0.382681 	},
{	-0.881923 	,	-0.471394 	},
{	-0.831471 	,	-0.555568 	},
{	-0.773013 	,	-0.634391 	},
{	-0.707109 	,	-0.707104 	},
{	-0.634396 	,	-0.773008 	},
{	-0.555573 	,	-0.831468 	},
{	-0.471400 	,	-0.881920 	},
{	-0.382687 	,	-0.923878 	},
{	-0.290288 	,	-0.956939 	},
{	-0.195094 	,	-0.980785 	},
{	-0.098021 	,	-0.995184 	},
{	-0.000004 	,	-1.000000 	},
{	0.098013 	,	-0.995185 	},
{	0.195086 	,	-0.980786 	},
{	0.290281 	,	-0.956942 	},
{	0.382679 	,	-0.923881 	},
{	0.471393 	,	-0.881923 	},
{	0.555567 	,	-0.831472 	},
{	0.634390 	,	-0.773013 	},
{	0.707103 	,	-0.707110 	},
{	0.773007 	,	-0.634397 	},
{	0.831467 	,	-0.555574 	},
{	0.881919 	,	-0.471401 	},
{	0.923878 	,	-0.382688 	},
{	0.956939 	,	-0.290290 	},
{	0.980784 	,	-0.195095 	},
{	0.995184 	,	-0.098022 	},
};

//float dft_in[N];
DFT_Complex dft_out[N];
DFT_Complex fft[N];
float fft_out[N];
//float Amp[N];

void DFT_Cal(uint16_t *dft_in, float *dft_amp)
{
	// X[i]=∑x[i]*e^(2*PI*i/N*j)
	//欧拉公式 e^x=cos(x)-j*sin(x)
	for(int i = 0; i < N; i++)
	{
		dft_out[i].real = 0;
		dft_out[i].image = 0;
		for(int j = 0; j < N; j++)
		{
			dft_out[i].real += cos(2*PI*i/N*j)*(*(dft_in+j));
			dft_out[i].image += -sin(2*PI*i/N*j)*(*(dft_in+j));
		}
		*(dft_amp+i) = sqrt(dft_out[i].real*dft_out[i].real + dft_out[i].image*dft_out[i].image);
	}
}

void Rader(uint16_t* arr,int n)	//雷德算法，用于求数列倒序
{
	float temp = 0;
	int i = 0,j = 0;
	int k = 0;
	for(i = 1,j = n/2; i < n-1; i++)	//第一个和最后一个不用管，i和2/N交换
	{
		if(i < j)	//i<j才交换，不然重复了
		{
			temp = *(arr+i);
			*(arr+i) = *(arr+j);
			*(arr+j) = temp;
		}
		k = n/2;
		while(j >= k)		//当j的最高位为1时
		{
			j -= k;		//发生进位
			k /= 2;		//更新k
		}
		j += k;			//最低位加1
	}
}

void Complex_Add(DFT_Complex A,DFT_Complex B,DFT_Complex* C)
{
	C->real  = A.real  + B.real;
	C->image = A.image + B.image;
}

void Complex_Sub(DFT_Complex A,DFT_Complex B,DFT_Complex* C)
{
	C->real  = A.real  - B.real;
	C->image = A.image - B.image;
}

void Complex_Mul(DFT_Complex A,DFT_Complex B,DFT_Complex* C)
{
	C->real  = A.real*B.real  - A.image*B.image;
	C->image = A.real*B.image + A.image*B.real;
}

void FFT_Cal(uint16_t* fft_in, float *amp)
{
	int i,j,k,l;
	DFT_Complex b_r,top,bottom;
	Rader(fft_in,N);	//使用雷德算法对fft_in进行倒序处理
	for(i = 0; i < N; i++)	//把fft_in的数据写入fft实部，虚部给0
	{
		fft[i].real = *(fft_in+i);
		fft[i].image = 0.0f;
	}
	//一级蝶形运算
	for(i = 0; i < LOG2N; i++)	//一共LOG2N级
	{
		l = 1<<i;	//1,2,4,8
		//二级蝶形运算
		for(j = 0; j < N; j += l*2)
		{
			//三级蝶形运算
			for(k = 0; k < l; k++)
			{
				Complex_Mul(fft[j+k+l],Rotation[N/(2*l)*k],&b_r);	//下面的乘旋转因子后保存在b_r中
				Complex_Add(fft[j+k],b_r,&top);	
				Complex_Sub(fft[j+k],b_r,&bottom);
				fft[j+k] = top;
				fft[j+k+l] = bottom;
			}
		}
	}
	for(i = 0; i < N; i++)
	{
		amp[i] = sqrt(fft[i].real*fft[i].real + fft[i].image*fft[i].image);
	}
}
